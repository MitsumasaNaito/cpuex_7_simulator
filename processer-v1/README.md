# MIPSプロセッサシミュレータ

Rustで実装されたMIPS形式の機械語で書かれたプログラムを実行するプロセッサシミュレータです。

## 機能

- MIPS命令セットの実装（R形式、I形式、J形式）
- メモリシステム（16MB、バイト単位アクセス）
- キャッシュシステム（4ウェイ・セット連想、32バイトライン）
- プロセッサコア（32個の汎用レジスタ）
- デバッグモード・ステップ実行モード

## プロジェクト構造

```
src/
├── main.rs          # メインシミュレータ
├── instructions.rs  # MIPS命令セット定義
├── memory.rs        # メモリシステム
├── cache.rs         # キャッシュシステム
└── processor.rs     # プロセッサコア
```

## ビルドと実行

### 前提条件

- Rust 1.70以上

### ビルド

```bash
cargo build --release
```

### 実行

```bash
# 基本的な実行
cargo run fibonacci.hex

# デバッグモードで実行
cargo run -- --debug fibonacci.hex

# ステップ実行モードで実行
cargo run -- --step fibonacci.hex

# メモリサイズを指定して実行
cargo run -- --memory-size 16777216 fibonacci.hex
```

## サンプルプログラム

`fibonacci.hex`には、第10項のフィボナッチ数を計算するMIPS機械語プログラムが含まれています。

### フィボナッチプログラムの動作

1. `$t0`に計算する項数（10）を設定
2. `$t1`にF(0)=0、`$t2`にF(1)=1を設定
3. ループでF(i) = F(i-1) + F(i-2)を計算
4. 結果を`$v0`に格納

## 実装されたMIPS命令

### R形式命令
- `add` - 加算
- `sub` - 減算
- `and` - 論理積
- `or` - 論理和
- `slt` - 符号付き比較
- `sll` - 左シフト
- `srl` - 右シフト
- `jr` - レジスタジャンプ

### I形式命令
- `addi` - 即値加算
- `lw` - ワードロード
- `sw` - ワードストア
- `beq` - 等価分岐
- `bne` - 不等価分岐
- `slti` - 即値比較

### J形式命令
- `j` - 無条件ジャンプ
- `jal` - リンク付きジャンプ

### システム命令
- `syscall` - システムコール

## レジスタ

- `$0` ($zero) - 常に0
- `$1` ($at) - アセンブラ一時レジスタ
- `$2-$3` ($v0-$v1) - 関数戻り値
- `$4-$7` ($a0-$a3) - 関数引数
- `$8-$15` ($t0-$t7) - 一時レジスタ
- `$16-$23` ($s0-$s7) - 保存レジスタ
- `$24-$25` ($t8-$t9) - 一時レジスタ
- `$26-$27` ($k0-$k1) - カーネル用
- `$28` ($gp) - グローバルポインタ
- `$29` ($sp) - スタックポインタ
- `$30` ($fp) - フレームポインタ
- `$31` ($ra) - 戻りアドレス

## キャッシュ仕様

- サイズ: 4ウェイ・セット連想
- セット数: 64
- ラインサイズ: 32バイト
- 置換アルゴリズム: LRU（Least Recently Used）

## デバッグ機能

- レジスタ状態の表示
- メモリダンプ
- キャッシュ統計情報
- ステップ実行
- 実行統計情報

## 制限事項

- 浮動小数点命令は未実装
- 乗除算命令は未実装
- システムコールは簡略化
- 割り込み処理は未実装

## ライセンス

MIT License


# フィボナッチ数計算プログラム（MIPS機械語）
# 第10項のフィボナッチ数を計算し、結果を$v0に格納

# 初期化
2008000A  # addi $t0, $zero, 10    # n = 10
20090000  # addi $t1, $zero, 0     # a = 0 (F(0))
200A0001  # addi $t2, $zero, 1     # b = 1 (F(1))
200B0002  # addi $t3, $zero, 2     # i = 2

# n <= 1 の場合は特別処理
1100000A  # beq $t0, $zero, end    # if n == 0, goto end
21080001  # addi $t0, $t0, -1      # n = n - 1
1100000A  # beq $t0, $zero, end    # if n == 1, goto end

# メインループ
0148082A  # slt $at, $t3, $t0      # if i < n
10200005  # beq $at, $zero, end    # if i >= n, goto end

# フィボナッチ計算: temp = a + b, a = b, b = temp
012A4820  # add $t1, $t1, $t2      # temp = a + b
014B5020  # add $t2, $t2, $t1      # a = b, b = temp

# ループカウンタを増加
216B0001  # addi $t3, $t3, 1       # i = i + 1
0800000A  # j loop                 # goto loop

# 終了（結果は$t2に格納）
01401020  # add $v0, $t2, $zero    # $v0 = result
0000000C  # syscall                # システムコール（終了）
